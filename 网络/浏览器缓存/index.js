// https://www.jianshu.com/p/54cc04190252
// 缓存是性能优化中一种简单高效的优化方式，可以帮助我们缩短网页请求资源的距离，减少延迟，并且缓存文件可重复利用，减少带宽和网络负荷
// 我们请求一个数据，可以分为发起请求，后端处理，浏览器相应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。
// 比如使用缓存，而不用发起请求。或者发起来请求，但是后端储存的数据和前端一致，那么就没必要将数据没返回，从而减少了相应数据。

// 从缓存位置上来说，分为四种，并且各自有优先级：
// Service Worker
// Memory Cache
// Disk Cache
// Push Cache

// 当上面四种全没有命中时，只能发起请求来获取资源

// 为了性能上的考虑，大部分接口都应该选择好的缓存策略，浏览器缓存策略通常分为两种：强缓存和协商缓存，都是通过设置HTTP Header来实现的

// 浏览器缓存机制：
// 浏览器每次发起请求，都会在浏览器缓存中查找该请求结果和缓存标识
// 浏览器每次拿到返回结果，都会将该结果和缓存标识存入浏览器缓存中

// 一、强缓存: 不会向服务器发起请求，直接从缓存中读取资源
// 实现：Expires 和 Cache-Control

// 1.Expires
// 指定资源到期时间，记录的是绝对值，需要配合Last-modified结合使用。
// Expiries是服务器响应消息头字段，它告诉浏览器在过期时间前可以直接从浏览器缓存读取数据，无需再次请求

// 2.Cache-Control
// 记录的时间是相对值
// 可以在请求头或者响应头中设置，多了一堆指令
// max-age=30 缓存在30过后就过期，需要重新请求
// no-store   不缓存任何响应

// 两者对比：
// Expires是Http1.0的产物，Cache-control是http1.1的产物，如果同时存在，Cache-Control的优先级高于Expires，Expires的存在只是一种兼容性的写法

// 二、协商缓存：在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器决定是否使用缓存的过程
// 实现：Last-Modified和ETag

// 1.Last-Modified

// 第一次请求资源时，服务器在response header中添加Last-Modified的字段，值为这个资源在服务器上的最后修改时间，浏览器接受后缓存文件和header，
// 浏览器下一次请求这个资源时，检测到有Last-Modified这个header，于是在请求头中添加If-Modified-Since这个hander，值就是Last-Modified的值，然后服务器比较这两个值，
// 如果时间一致，说明协商缓存生效，返回304和空的响应体，直接从缓存读取，
// 如果时间不一致，即If-Modified-Since小于Last-Modified，说明文件有更新，协商缓存失效，于是返回新的资源文件和200

// 2.ETag
// Etag是服务器响应时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，Etag就会重新生成
// 浏览器在下一次请求资源时，会把Etag的值放在请求头的If-None-Match里，服务器只要比较客户端传过来的If-None-Match跟自己服务器上该资源的Etag是否一致，就能知道资源相对于客户端来说是否被修改过了。
// 如果Etag一致，返回304和空响应体，直接使用本地缓存
// 如果不一致，返回200和新的资源

// 两者对比：
// 精度上，Etag优于Last-Modified
// 性能上，Etag要逊色于Last-Modified，因为Etag要通过算法来计算出一个hash值
// 优先级上，服务器校验优先考虑Etag
